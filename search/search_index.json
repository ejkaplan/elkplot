{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ElkPlot","text":"<p>Author: El Kaplan (@elkplots on Instagram) Copyright: This work is licensed under a Creative Commons Attribution 3.0 United States License Github Repo: github.com/ejkaplan/elkplot Version: 0.2.0</p> <p>This Python library is built to facilitate using shapely to create generative art to be plotted with an AxiDraw pen plotter. The library is MIT licensed and free for use, including modification.</p> <p>I wrote elkplot specifically to play nicely with my personal workflow for creating generative art, and I make it available in the hopes that other plotter artists will be able to make use of it. Feel free to check out my instagram, linked above (shameless plug) for examples of the kind of work I create using elkplot.</p>"},{"location":"alternatives/","title":"Alternative Libraries","text":"<p>I'd be remiss if I didn't acknowledge the existence of the following generative art/pen plotting libraries, all of which directly influenced the creation of elkplot. I have used all of them for creating art, was inspired be design decisions in all of them, and would not blame you for looking at any of them and deciding to use them instead of elkplot. There will be absolutely no hard feelings if you do. \ud83d\ude04</p>"},{"location":"alternatives/#processing","title":"Processing","text":"<p>I first got started with generative art in Processing, and you absolutely can export as .svg and plot using the AxiDraw Inkscape plugin. I ultimately left processing behind because I wanted something that worked better with multi-layer plots, and also I prefer to work in Python.</p>"},{"location":"alternatives/#vsketch","title":"vsketch","text":"<p>vsketch is a profoundly cool tool that draws inspiration in its coding style from Processing. It was a really natural next step for me, and the interactive plotting window that allows you to live-tweak parameters of your drawing and see the updated results in real-time is a feature that I badly miss and would love to incorporate into elkplot at some point in the future. vsketch also has native support for shapely, which introduced me to the amazing capabilities of that library. I ultimately moved away from working in vsketch because I wanted my code to directly control the axidraw rather than having to export an .svg and then plot from Inkscape, but I can't recommend giving it a try highly enough.</p>"},{"location":"alternatives/#axi","title":"axi","text":"<p>axi was written by Michael Fogleman as an unofficial alternative to the official AxiDraw Python API, and for a very long time it was my primary tool for creating plotter art. My artistic workflow is different from Fogleman's, and so I forked the project and made my own version that gradually diverged more and more from the original as I patched in little tools for myself until eventually it became a bit of a mess, at which point I decided to start elkplot. elkplot's text generation, fonts, and the trapezoidal velocity motion planning code are directly taken (with permission) from axi, and for this I am profoundly grateful.</p>"},{"location":"examples/","title":"Examples","text":"<p>All examples can be found in the examples module. For each example, click the link in the header to see the code on github.</p>"},{"location":"examples/#schotter","title":"Schotter","text":"<p>This is a famous early instance of generative art by the artist Geog Nees, and the code demonstrates a lot of the techniques that I use all the time when making art.</p> <ul> <li> <p>In the example as written, the random number generator is given the seed 0. You can change that line   to <code>rng = np.random.defaut_rng()</code> if you want distinct outputs every time you run the program.</p> </li> <li> <p>In works with multiple instances of similar repeated shapes, I'll create a single shape and then in a loop create   transformed duplicates using  shapely's affine transformation functions.   For a simple example, below is how I'd create a list of five squares of size 1 next to each other with a gap of 0.2   between them.</p> <pre><code>import shapely\nfrom shapely import affinity\nsquare = shapely.LinearRing([(0, 0), (0, 1), (1, 1), (1, 0)])\nsquares = [affinity.translate(square, i * 1.2, 0) for i in range(5)]\n</code></pre> </li> <li> <p>When I was first composing the image, having the amount of random offset increase linearly across the page made things   look too chaotic too fast - I wanted the left side of the page to stay more orderly for longer. So I used   a sine ease-in to have the coefficient of chaos rise slowly on the left and faster towards the   right.</p> </li> <li> <p>Inside the <code>schotter</code> function, I collected a bunch of squares in a list that I called <code>shapes</code>. At the very end of   the function, I   used <code>shapely.union_all</code>   to merge them together into a single <code>MultiLineString</code>. Because all the contents of the <code>shapes</code> list are 1D lines, I   also could alternately have passed the list into the constructor for <code>MultiLineString</code>. In the example   below, <code>combined_0</code> and <code>combined_1</code> will look identical when plotted. I like <code>union_all</code> better personally, but I   have no reason why I like it better. \ud83e\udd37\u200d\u2640\ufe0f</p> <pre><code>import shapely\n\nshapes = [...]  # A bunch of shapely.LineString and/or shapely.LinearRing objects\ncombined_0 = shapely.MultiLineString(shapes)\ncombined_1 = shapely.union_all(shapes)\n</code></pre> </li> <li> <p>At the very end, I print the metrics before and after optimization     <pre><code>    print(elkplot.metrics(drawing))  # 1496 paths, pen down: 486.52 inch, pen up: 237.02 inch\n    drawing = elkplot.optimize(drawing, 0.01)\n    print(elkplot.metrics(drawing))  # 88 paths, pen down: 486.61 inch, pen up: 82.14 inch\n</code></pre>   This serves no practical purpose, it just demonstrates that the optimize function is   in fact doing something. You can see that the distance the pen travels while in contact with the page increased   slightly, but the pen up distance decreased dramatically, as did the number of distinct paths. When we set the   tolerance of <code>optimize</code> to 0.01 we were allowing <code>optimize</code> to insert extra lines between the ends of paths that are   less than a hundredth of an inch apart connecting them and preventing us from having to lift the pen between the two   paths, which explains the decrease in the number of paths. The reduction in the pen up distance is mostly due to   re-ordering the paths - by drawing paths that are close to each other sequentially we can prevent the pen from   criss-crossing all over the page while in the air, dramatically decreasing plot times.</p> </li> </ul>"},{"location":"examples/#multi-layer-plotting","title":"Multi-Layer Plotting","text":"<p>In this example, three images are combined in a <code>shapely.GeometryCollection</code>. The <code>draw</code> function interprets these three elements as different layers. When plotted, elkplot will draw the first layer (the blue circles in the preview) and then return to home position and pause, so you can swap out the pen. It will prompt you to press enter when you're ready and then it'll plot the second layer (red in the preview) and then the same process for the third (green in the preview)</p> <p>Note that because <code>shapely.GeometryCollection</code> is still a shapely geometry, a lot of our functions for manipulating shapes can still be used. For example, <code>scale_to_fit</code>.</p> <pre><code>circles = shapely.GeometryCollection([left_circles, right_circles, top_circles])\ncircles = elkplot.scale_to_fit(circles, *size, margin)\n</code></pre>"},{"location":"examples/#set-theoretic-construction","title":"Set Theoretic Construction","text":"<p>Set theoretic construction is building shapes out of polygons by merging them with <code>union</code> and using polygons to cut away at other polygons with <code>shapely.difference</code> and <code>shapely.intersection</code>. Normally we deal in <code>shapely.LineString</code>s and <code>shapely.MultiLineString</code>s when making art for a plotter because it only actually draws one-dimensional lines. However, in this context we want to use <code>shapely.Polygon</code> because the interior of the shapes is relevant. (The intersection of two polygons is another polygon. The intersection of two linestrings is just the set of points where those linestrings cross each other.)</p> <p>In this example, a single shape is created, and then the rest of the composition is created by using affine transformations and the <code>union</code> and <code>difference</code> functions.</p> <pre><code>@elkplot.UNITS.wraps(None, (\"inch\", \"inch\", \"inch\"), False)\ndef overlapping_star(x: float, y: float, r: float) -&gt; shapely.GeometryCollection:\n    triangle = shapely.Polygon(\n        [\n            (x + r * np.cos(theta), y + r * np.sin(theta))\n            for theta in np.linspace(0, 2 * np.pi, 3, endpoint=False)\n        ]\n    )\n    # Create a star by merging two triangles that point in opposite directions\n    star_poly = triangle.union(\n        affinity.rotate(triangle, np.pi, use_radians=True, origin=\"centroid\")\n    )\n    # Reduce that star to a ribbon around the edge by cutting away a smaller version of the same\n    top_star_ribbon = star_poly.difference(\n        affinity.scale(star_poly, 0.95, 0.95, origin=\"centroid\")\n    )\n    # Make a second star that is a rotated version of the first one\n    bottom_star_ribbon = affinity.rotate(\n        top_star_ribbon, np.pi / 6, use_radians=True, origin=\"centroid\"\n    )\n    # Cut away the parts of the second star that are covered up by the first one, plus a little wiggle room\n    bottom_star_ribbon = bottom_star_ribbon.difference(top_star_ribbon.buffer(0.05))\n    return shapely.GeometryCollection([top_star_ribbon, bottom_star_ribbon])\n</code></pre> <p>Also worth noting about that function, the <code>pint.wraps</code> decorator allows the function to take as input floating point numbers (which will be assumed to be in inches) or any pint <code>Quantity</code> object, which will be converted into inches. This allows us to use whatever units we want when the function is called and not worry about consistency in the body of the function. (<code>elkplot.UNITS</code> is a <code>UnitRegistry</code> that is instantiated in the library.)</p>"},{"location":"setup/","title":"Setup","text":"<p>elkplot manages its dependencies using Poetry. If your project also uses poetry, all you need to do is the following:</p> <pre><code>poetry add git+https://github.com/ejkaplan/elkplot\n</code></pre> <p>If you are using any other virtual environment manager (venv, conda, etc.) the following should work just fine:</p> <pre><code>pip install \"git+https://github.com/ejkaplan/elkplot\"\n</code></pre> <p>You can verify that it worked by calling the following in your terminal...</p> <pre><code>elk --help\n</code></pre> <p>and if you see the CLI reference pop up you'll know you're good to go!</p>"},{"location":"tips_and_tricks/","title":"Tips and Tricks","text":""},{"location":"tips_and_tricks/#scale-factor","title":"Scale Factor","text":"<p>Do not be afraid to make your artwork at whatever scale is easiest and then make a call to <code>elkplot.scale_to_fit()</code> at the end. For example, if I'm making a drawing that is built around a square grid, I'll usually make the grid cells 1 inch x 1 inch to make the math convenient, and scale at the end. Just make sure to call <code>elkplot.optimize()</code> after you scale so that <code>optimize</code>'s <code>tolerance</code> argument is in the same scale as the drawing.</p>"},{"location":"api_ref/cli/","title":"The <code>elk</code> CLI","text":"<p>ElkPlot comes with a CLI that you can use in any environment in which the package is installed. The cli command is <code>elk</code>, and you can use the following commands to directly control the AxiDraw. The usage is fairly self-explanatory, but a good starting point is calling <code>elk --help</code></p> <pre><code>&gt; elk --help\nUsage: elk [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  down  Bring the pen down onto the page\n  goto  Move the pen directly to the point (x, y)\n  home  Return the pen to (0, 0)\n  move  Offset the pen's current position.\n  off   Disable the AxiDraw's motors\n  on    Enable the AxiDraw's motors\n  up    Lift the pen off the page\n  zero  Set the current location as (0, 0)\n</code></pre> <p>Note that for the <code>elk move</code> command, you need to use a double hyphen to indicate moving in the negative direction. For example, <code>elk move 2 --3</code> will move the pen 2 inches to the right and 3 inches up.</p>"},{"location":"api_ref/easing/","title":"Easing","text":"<p>For convenience, I've included a bunch of easing functions because they are very useful in generative art. Easing functions are mathematical functions that map numbers in the range [0, 1] to numbers in the range [0, 1], such that <code>ease(0)</code> always returns <code>0</code> and <code>ease(1)</code> always returns <code>1</code>. Different easing functions do different things in the middle, but there are three main flavors:</p> <ul> <li>An ease-in starts slow and speeds up towards the end.</li> <li>An ease-out starts fast and slows down towards the end.</li> <li>An ease-in-out starts slow, gets fast in the middle, and then slows down again at the end.</li> </ul> <p>If you want to understand easing functions in more detail, check out this cheat sheet.</p> <p><code>elkplot.easing.ease_in_sine</code> <code>elkplot.easing.ease_out_sine</code> <code>elkplot.easing.ease_in_out_sine</code> <code>elkplot.easing.ease_in_nth_order</code> <code>elkplot.easing.ease_out_nth_order</code> <code>elkplot.easing.ease_in_out_nth_order</code> <code>elkplot.easing.ease_in_expo</code> <code>elkplot.easing.ease_out_expo</code> <code>elkplot.easing.ease_in_out_expo</code> <code>elkplot.easing.ease_in_circ</code> <code>elkplot.easing.ease_out_circ</code> <code>elkplot.easing.ease_in_out_circ</code> <code>elkplot.easing.ease_in_back</code> <code>elkplot.easing.ease_out_back</code> <code>elkplot.easing.ease_in_out_back</code> <code>elkplot.easing.ease_in_elastic</code> <code>elkplot.easing.ease_out_elastic</code> <code>elkplot.easing.ease_in_out_elastic</code> <code>elkplot.easing.ease_in_bounce</code> <code>elkplot.easing.ease_out_bounce</code> <code>elkplot.easing.ease_in_out_bounce</code></p>"},{"location":"api_ref/easing/#usage","title":"Usage","text":"<p>All the easing functions accept one argument representing the x-value in [0, 1], and all of them will return the y-value in [0, 1]. All of them accept any <code>ArrayLike</code> argument. If you want to check the value of the easing function at many different x-coordinates, you can pass in a list of floats or a 1D numpy array.</p> <pre><code>import numpy as np\n\nimport elkplot.easing\n\neased = elkplot.easing.ease_in_bounce(0.4)\nprint(eased)  # 0.2275\n\nx = np.linspace(0, 1, 5)\neased = elkplot.easing.ease_in_back(x)\nprint(eased)  # [ 0.        -0.0640625 -0.0875     0.1828125  1.       ]\n</code></pre> <p>The following easing functions have optional extra arguments:</p>"},{"location":"api_ref/easing/#elkplot.easing.ease_in_back","title":"<code>ease_in_back(x, c=1.7)</code>","text":"<p>Pull slightly negative at the start before blasting off towards (1, 1) Args:     x: The x-coordinate in [0, 1]     c: The degree to which it pulls back into the negative before racing to 1.         (If this is 0, it just becomes cubic easing.)</p> <p>Returns:</p> Type Description <code>ArrayLike</code> <p>The y-coordinate in [0, 1]</p> Source code in <code>elkplot/easing.py</code> <pre><code>def ease_in_back(x: npt.ArrayLike, c: float = 1.7) -&gt; npt.ArrayLike:\n    \"\"\"\n    Pull slightly negative at the start before blasting off towards (1, 1)\n    Args:\n        x: The x-coordinate in [0, 1]\n        c: The degree to which it pulls back into the negative before racing to 1.\n            (If this is 0, it just becomes cubic easing.)\n\n    Returns:\n        The y-coordinate in [0, 1]\n    \"\"\"\n    return (1 + c) * np.power(x, 3) - c * np.power(x, 2)\n</code></pre>"},{"location":"api_ref/easing/#elkplot.easing.ease_in_elastic","title":"<code>ease_in_elastic(x, c=2 * np.pi / 3)</code>","text":"<p>Wiggles back and forth before going off to (1, 1) Args:     x: The x-coordinate in [0, 1]     c: The \"bounciness\" factor.</p> <p>Returns:</p> Type Description <code>ArrayLike</code> <p>The y-coordinate in [0, 1]</p> Source code in <code>elkplot/easing.py</code> <pre><code>def ease_in_elastic(x: npt.ArrayLike, c: float = 2 * np.pi / 3) -&gt; npt.ArrayLike:\n    \"\"\"\n    Wiggles back and forth before going off to (1, 1)\n    Args:\n        x: The x-coordinate in [0, 1]\n        c: The \"bounciness\" factor.\n\n    Returns:\n        The y-coordinate in [0, 1]\n    \"\"\"\n    return np.select(\n        [x == 0, x == 1],\n        [0, 1],\n        -np.power(2, 10 * x - 10) * np.sin((x * 10 - 10.75) * c),\n    )\n</code></pre>"},{"location":"api_ref/easing/#elkplot.easing.ease_in_nth_order","title":"<code>ease_in_nth_order(x, n=2)</code>","text":"<p>Nth order ease in. Args:     x: The x-coordinate in [0, 1]     n: The order of the polynomial. (n=2 is quadratic ease in, n=3 is cubic, etc.)</p> <p>Returns:</p> Type Description <code>ArrayLike</code> <p>The y-coordinate in [0, 1]</p> Source code in <code>elkplot/easing.py</code> <pre><code>def ease_in_nth_order(x: npt.ArrayLike, n: int = 2) -&gt; npt.ArrayLike:\n    \"\"\"\n    Nth order ease in.\n    Args:\n        x: The x-coordinate in [0, 1]\n        n: The order of the polynomial. (n=2 is quadratic ease in, n=3 is cubic, etc.)\n\n    Returns:\n        The y-coordinate in [0, 1]\n    \"\"\"\n    return np.power(x, n)\n</code></pre>"},{"location":"api_ref/easing/#elkplot.easing.ease_in_out_back","title":"<code>ease_in_out_back(x, c=1.7)</code>","text":"<p>Pull slightly negative at the start and overshoots slightly over at the end before pulling back to (1, 1) Args:     x: The x-coordinate in [0, 1]     c: The degree to which it overshoots/pulls back         (If this is 0, it just becomes cubic easing.)</p> <p>Returns:</p> Type Description <code>ArrayLike</code> <p>The y-coordinate in [0, 1]</p> Source code in <code>elkplot/easing.py</code> <pre><code>def ease_in_out_back(x: npt.ArrayLike, c: float = 1.7) -&gt; npt.ArrayLike:\n    \"\"\"\n    Pull slightly negative at the start and overshoots slightly over at the end before pulling back to (1, 1)\n    Args:\n        x: The x-coordinate in [0, 1]\n        c: The degree to which it overshoots/pulls back\n            (If this is 0, it just becomes cubic easing.)\n\n    Returns:\n        The y-coordinate in [0, 1]\n    \"\"\"\n    c2 = c * 1.525\n    return np.where(\n        x &lt; 0.5,\n        (np.power(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2,\n        (np.power(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,\n    )\n</code></pre>"},{"location":"api_ref/easing/#elkplot.easing.ease_in_out_elastic","title":"<code>ease_in_out_elastic(x, c=2 * np.pi / 4.5)</code>","text":"<p>Wiggles about y=0 at the start with the wiggles increasing in magnitude, then races up to y=1 and damps down to a constant at (1, 1) Args:     x: The x-coordinate in [0, 1]     c: The \"bounciness\" factor.</p> <p>Returns:</p> Type Description <code>ArrayLike</code> <p>The y-coordinate in [0, 1]</p> Source code in <code>elkplot/easing.py</code> <pre><code>def ease_in_out_elastic(x: npt.ArrayLike, c: float = 2 * np.pi / 4.5) -&gt; npt.ArrayLike:\n    \"\"\"\n    Wiggles about y=0 at the start with the wiggles increasing in magnitude, then races up to y=1 and damps down to a\n    constant at (1, 1)\n    Args:\n        x: The x-coordinate in [0, 1]\n        c: The \"bounciness\" factor.\n\n    Returns:\n        The y-coordinate in [0, 1]\n    \"\"\"\n    return np.select(\n        [x == 0, x == 1, x &lt; 0.5],\n        [0, 1, -(np.power(2, 20 * x - 10) * np.sin((20 * x - 11.125) * c)) / 2],\n        (np.power(2, -20 * x + 10) * np.sin((20 * x - 11.125) * c)) / 2 + 1,\n    )\n</code></pre>"},{"location":"api_ref/easing/#elkplot.easing.ease_in_out_nth_order","title":"<code>ease_in_out_nth_order(x, n=2)</code>","text":"<p>Nth order ease in and out. Args:     x: The x-coordinate in [0, 1]     n: The order of the polynomial. (n=2 is quadratic ease in and out, n=3 is cubic, etc.)</p> <p>Returns:</p> Type Description <code>ArrayLike</code> <p>The y-coordinate in [0, 1]</p> Source code in <code>elkplot/easing.py</code> <pre><code>def ease_in_out_nth_order(x: npt.ArrayLike, n: int = 2) -&gt; npt.ArrayLike:\n    \"\"\"\n    Nth order ease in and out.\n    Args:\n        x: The x-coordinate in [0, 1]\n        n: The order of the polynomial. (n=2 is quadratic ease in and out, n=3 is cubic, etc.)\n\n    Returns:\n        The y-coordinate in [0, 1]\n    \"\"\"\n    return np.where(\n        x &lt; 0.5, np.power(2, n - 1) * np.power(x, n), 1 - np.power(-2 * x + 2, n) / 2\n    )\n</code></pre>"},{"location":"api_ref/easing/#elkplot.easing.ease_out_back","title":"<code>ease_out_back(x, c=1.7)</code>","text":"<p>Overshoots slightly over 1 before pulling back to (1, 1) Args:     x: The x-coordinate in [0, 1]     c: The degree to which it overshoots 1 before pulling back.         (If this is 0, it just becomes cubic easing.)</p> <p>Returns:</p> Type Description <code>ArrayLike</code> <p>The y-coordinate in [0, 1]</p> Source code in <code>elkplot/easing.py</code> <pre><code>def ease_out_back(x: npt.ArrayLike, c: float = 1.7) -&gt; npt.ArrayLike:\n    \"\"\"\n    Overshoots slightly over 1 before pulling back to (1, 1)\n    Args:\n        x: The x-coordinate in [0, 1]\n        c: The degree to which it overshoots 1 before pulling back.\n            (If this is 0, it just becomes cubic easing.)\n\n    Returns:\n        The y-coordinate in [0, 1]\n    \"\"\"\n    return 1 + (1 + c) * np.power(x - 1, 3) + c * np.power(x - 1, 2)\n</code></pre>"},{"location":"api_ref/easing/#elkplot.easing.ease_out_elastic","title":"<code>ease_out_elastic(x, c=2 * np.pi / 3)</code>","text":"<p>Like a snapping elastic band, gets to the top very quickly and then wiggles about y=1 until the wiggles damp down to a constant at (1, 1) Args:     x: The x-coordinate in [0, 1]     c: The \"bounciness\" factor.</p> <p>Returns:</p> Type Description <code>ArrayLike</code> <p>The y-coordinate in [0, 1]</p> Source code in <code>elkplot/easing.py</code> <pre><code>def ease_out_elastic(x: npt.ArrayLike, c: float = 2 * np.pi / 3) -&gt; npt.ArrayLike:\n    \"\"\"\n    Like a snapping elastic band, gets to the top very quickly and then wiggles about y=1 until the wiggles damp down\n    to a constant at (1, 1)\n    Args:\n        x: The x-coordinate in [0, 1]\n        c: The \"bounciness\" factor.\n\n    Returns:\n        The y-coordinate in [0, 1]\n    \"\"\"\n    return np.select(\n        [x == 0, x == 1], [0, 1], np.power(2, -10 * x) * np.sin((x * 10 - 0.75) * c) + 1\n    )\n</code></pre>"},{"location":"api_ref/easing/#elkplot.easing.ease_out_nth_order","title":"<code>ease_out_nth_order(x, n=2)</code>","text":"<p>Nth order ease out. Args:     x: The x-coordinate in [0, 1]     n: The order of the polynomial. (n=2 is quadratic ease out, n=3 is cubic, etc.)</p> <p>Returns:</p> Type Description <code>ArrayLike</code> <p>The y-coordinate in [0, 1]</p> Source code in <code>elkplot/easing.py</code> <pre><code>def ease_out_nth_order(x: npt.ArrayLike, n: int = 2) -&gt; npt.ArrayLike:\n    \"\"\"\n    Nth order ease out.\n    Args:\n        x: The x-coordinate in [0, 1]\n        n: The order of the polynomial. (n=2 is quadratic ease out, n=3 is cubic, etc.)\n\n    Returns:\n        The y-coordinate in [0, 1]\n    \"\"\"\n    return 1 - np.power(1 - x, n)\n</code></pre>"},{"location":"api_ref/making_art/","title":"Making Art","text":"<p>ElkPlot assumes that you are creating your plotter art using the Shapely Python library. This documentation assumes that you are already comfortable/familiar with Shapely. ElkPlot primarily deals with <code>LineString</code>, <code>MultiLineString</code>, and <code>GeometryCollection</code>, so you should try to compose your art in terms of these types.</p> <ul> <li>A <code>LineString</code> will be plotted as a single stroke of the pen - the plotter will go to the first coordinate in the <code>LineString</code>, put the pen down, and then travel to each subsequent coordinate until it reaches the end of the <code>LineString</code> at which point the pen will be lifted again. (A <code>LinearRing</code> will be plotted as though it were a LineString with the first coordinate duplicated at the end.)</li> <li>A <code>MultiLineString</code> will be plotted as multiple discrete strokes. The plotter draws each <code>LineString</code> contained within in the order that they are given, lifting the pen between each <code>LineString</code> in order to travel to the next.</li> <li>A <code>GeometryCollection</code> will be treated as multiple passes with multiple pens. If you have a drawing that uses two colors, you should compose a <code>MultiLineString</code> containing all the lines to be drawn in the first color, and a second <code>MultiLineString</code> containing all the lines to be drawn in the second color. Then create a <code>GeometryCollection</code> containing both.</li> </ul> <pre><code>import shapely\n\nfirst_color = shapely.MultiLineString([...])\nsecond_color = shapely.MultiLineString([...])\ndrawing = shapely.GeometryCollection([first_color, second_color])\n</code></pre>"},{"location":"api_ref/making_art/#helpful-functions-for-creating-plottable-shapely-geometry","title":"Helpful Functions for Creating Plottable Shapely Geometry","text":"<p>The following functions can be imported directly from elkplot and help manipulate Shapely geometry in specific ways that are useful for plotting.</p>"},{"location":"api_ref/making_art/#elkplot.shape_utils.center","title":"<code>center(drawing, width, height, x=0, y=0)</code>","text":"<p>Return a copy of a drawing that has been translated (but not scaled) to the center point of a given rectangle Args:     drawing: The drawing to translate     width: The width of the rectangle in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)     height: The height of the rectangle in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)     x: x-coordinate of the upper-left corner of the rectangle in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)     y: y-coordinate of the upper-left corner of the rectangle in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)</p> <p>Returns:</p> Type Description <code>Geometry</code> <p>A copy of the drawing having been translated to the center of the rectangle</p> Source code in <code>elkplot/shape_utils.py</code> <pre><code>@UNITS.wraps(None, (None, \"inch\", \"inch\", \"inch\", \"inch\"), False)\ndef center(\n    drawing: shapely.Geometry,\n    width: float,\n    height: float,\n    x: float = 0,\n    y: float = 0,\n) -&gt; shapely.Geometry:\n    \"\"\"\n    Return a copy of a drawing that has been translated (but not scaled) to the center point of a given rectangle\n    Args:\n        drawing: The drawing to translate\n        width: The width of the rectangle in inches (or any other unit if you pass in a `pint.Quantity`.)\n        height: The height of the rectangle in inches (or any other unit if you pass in a `pint.Quantity`.)\n        x: x-coordinate of the upper-left corner of the rectangle in inches (or any other unit if you pass in a `pint.Quantity`.)\n        y: y-coordinate of the upper-left corner of the rectangle in inches (or any other unit if you pass in a `pint.Quantity`.)\n\n    Returns:\n        A copy of the drawing having been translated to the center of the rectangle\n    \"\"\"\n    x_min, y_min, x_max, y_max = drawing.bounds\n    center_point = shapely.Point((x_min + x_max) / 2, (y_min + y_max) / 2)\n    dx, dy = x + width / 2 - center_point.x, y + height / 2 - center_point.y\n    return affinity.translate(drawing, dx, dy)\n</code></pre>"},{"location":"api_ref/making_art/#elkplot.shape_utils.flatten_geometry","title":"<code>flatten_geometry(geom)</code>","text":"<p>Given any arbitrary shapely Geometry, flattens it down to a single MultiLineString that will be rendered as a single color-pass if sent to the plotter. Also converts Polygons to their outlines - if you want to render a filled in Polygon, use the <code>shade</code> function. Args:     geom: The geometry to be flattened down. Most often this will be a GeometryCollection or a MultiPolygon.</p> <p>Returns:</p> Type Description <code>MultiLineString</code> <p>The flattened geometry</p> Source code in <code>elkplot/shape_utils.py</code> <pre><code>def flatten_geometry(geom: shapely.Geometry) -&gt; shapely.MultiLineString:\n    \"\"\"\n    Given any arbitrary shapely Geometry, flattens it down to a single MultiLineString that will be rendered as a\n    single color-pass if sent to the plotter. Also converts Polygons to their outlines - if you want to render a filled\n    in Polygon, use the `shade` function.\n    Args:\n        geom: The geometry to be flattened down. Most often this will be a GeometryCollection or a MultiPolygon.\n\n    Returns:\n        The flattened geometry\n    \"\"\"\n    if isinstance(geom, shapely.MultiLineString):\n        return geom\n    if isinstance(geom, (shapely.LineString, shapely.LinearRing)):\n        return shapely.multilinestrings([geom])\n    elif isinstance(geom, shapely.Polygon):\n        shapes = [geom.exterior] + list(geom.interiors)\n        return shapely.union_all([flatten_geometry(shape) for shape in shapes])\n    elif isinstance(geom, (shapely.GeometryCollection, shapely.MultiPolygon)):\n        parts = [flatten_geometry(sub_geom) for sub_geom in shapely.get_parts(geom)]\n        return shapely.union_all(parts)\n    return shapely.MultiLineString()\n</code></pre>"},{"location":"api_ref/making_art/#elkplot.shape_utils.layer_wise_merge","title":"<code>layer_wise_merge(*drawings)</code>","text":"<p>Combines two or more multi-layer drawings while keeping the layers separate. That is, creates a new drawing where the first layer is the union of all the input drawings' first layers, and the second layer is the union of all the input drawings' second layers, and so on. Args:     *drawings: All the drawings to be merged</p> <p>Returns:</p> Type Description <code>GeometryCollection</code> <p>The merged drawing</p> Source code in <code>elkplot/shape_utils.py</code> <pre><code>def layer_wise_merge(\n    *drawings: shapely.GeometryCollection,\n) -&gt; shapely.GeometryCollection:\n    \"\"\"\n    Combines two or more multi-layer drawings while keeping the layers separate. That is, creates a new drawing where\n    the first layer is the union of all the input drawings' first layers, and the second layer is the union of all the\n    input drawings' second layers, and so on.\n    Args:\n        *drawings: All the drawings to be merged\n\n    Returns:\n        The merged drawing\n    \"\"\"\n    layers = []\n    for drawing in drawings:\n        for i, layer in enumerate(shapely.get_parts(drawing)):\n            if i &gt;= len(layers):\n                layers.append([])\n            layers[i].append(layer)\n    return shapely.GeometryCollection([shapely.union_all(layer) for layer in layers])\n</code></pre>"},{"location":"api_ref/making_art/#elkplot.shape_utils.metrics","title":"<code>metrics(drawing)</code>","text":"<p>Calculate the pen down distance, pen up distance, and number of discrete paths (requiring penlifts between) in a given drawing. Args:     drawing:</p> <p>Returns:</p> Type Description <code>DrawingMetrics</code> <p>A <code>DrawingMetrics</code> object containing fields for <code>pen_down_dist</code>, <code>pen_up_dist</code>, and <code>path_count</code></p> Source code in <code>elkplot/shape_utils.py</code> <pre><code>def metrics(drawing: shapely.Geometry) -&gt; DrawingMetrics:\n    \"\"\"\n    Calculate the pen down distance, pen up distance, and number of discrete paths (requiring penlifts between) in a\n    given drawing.\n    Args:\n        drawing:\n\n    Returns:\n        A `DrawingMetrics` object containing fields for `pen_down_dist`, `pen_up_dist`, and `path_count`\n\n    \"\"\"\n    if isinstance(drawing, shapely.GeometryCollection):\n        out = DrawingMetrics(0 * UNITS.inch, 0 * UNITS.inch, 0)\n        for layer in shapely.get_parts(drawing):\n            out += metrics(flatten_geometry(layer))\n        return out\n    else:\n        return DrawingMetrics(\n            drawing.length * UNITS.inch,\n            up_length(drawing),\n            shapely.get_num_geometries(drawing),\n        )\n</code></pre>"},{"location":"api_ref/making_art/#elkplot.shape_utils.optimize","title":"<code>optimize(geometry, tolerance=0, sort=True, reloop=True, delete_small=True, pbar=True)</code>","text":"<p>Optimize a shapely geometry for plotting by combining paths, re-ordering paths, and/or deleting short paths. Always merges paths whose ends are closer together than a given tolerance. Can also randomize the starting point for closed loops to help hide the dots that appear at the moment the pen hits the page. Args:     geometry: The shapely geometry to be optimized. Usually this is either a <code>MultiLineString</code> or a         <code>GeometryCollection</code> depending on if you are optimizing a single layer or a multi-layer plot.     tolerance: The largest gap that should be merged/the longest line that should be deleted in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)     sort: Should the paths be re-ordered to minimize pen-up travel distance?     reloop: Should closed loop paths have their starting point randomized?     delete_small: Should paths shorter than <code>tolerance</code> be deleted?     pbar: Should progress bars be displayed to keep the user updated on the progress of the process?</p> <p>Returns:</p> Type Description <code>Geometry</code> <p>The optimized geometry</p> Source code in <code>elkplot/shape_utils.py</code> <pre><code>@UNITS.wraps(None, (None, \"inch\", None, None, None, None), False)\ndef optimize(\n    geometry: shapely.Geometry,\n    tolerance: float = 0,\n    sort: bool = True,\n    reloop: bool = True,\n    delete_small: bool = True,\n    pbar: bool = True,\n) -&gt; shapely.Geometry:\n    \"\"\"\n    Optimize a shapely geometry for plotting by combining paths, re-ordering paths, and/or deleting short paths.\n    Always merges paths whose ends are closer together than a given tolerance.\n    Can also randomize the starting point for closed loops to help hide the dots that appear at the moment the pen hits\n    the page.\n    Args:\n        geometry: The shapely geometry to be optimized. Usually this is either a `MultiLineString` or a\n            `GeometryCollection` depending on if you are optimizing a single layer or a multi-layer plot.\n        tolerance: The largest gap that should be merged/the longest line that should be deleted in inches (or any other unit if you pass in a `pint.Quantity`.)\n        sort: Should the paths be re-ordered to minimize pen-up travel distance?\n        reloop: Should closed loop paths have their starting point randomized?\n        delete_small: Should paths shorter than `tolerance` be deleted?\n        pbar: Should progress bars be displayed to keep the user updated on the progress of the process?\n\n    Returns:\n        The optimized geometry\n\n    \"\"\"\n    if reloop:\n        geometry = _reloop_paths(geometry)\n    geometry = _join_paths(geometry, tolerance, pbar)\n    if delete_small:\n        geometry = _delete_short_paths(geometry, tolerance, pbar)\n    if sort:\n        geometry = _sort_paths(geometry, pbar)\n    return geometry\n</code></pre>"},{"location":"api_ref/making_art/#elkplot.shape_utils.rotate_and_scale_to_fit","title":"<code>rotate_and_scale_to_fit(drawing, width, height, padding=0, increment=0.02)</code>","text":"<p>Fits a drawing into a bounding box of a given width and height, but unlike <code>scale_to_fit</code> also rotates the shape to make it take up as much of that area as possible. Also centers the object in that bounding box with the bounding box's upper-left corner at the origin. Args:     drawing: The shapely geometry to rescale     width: The width of the bounding box in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)     height: The height of the bounding box in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)     padding: How much space to leave empty on all sides in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)     increment: The gap between different rotation angles attempted in radians. (smaller value gives better results,         but larger values run faster.)</p> <p>Returns:</p> Type Description <code>Geometry</code> <p>A copy of the drawing having been rotated, rescaled, and moved such that the new upper-left corner of the bounding box (including the padding) is at the origin</p> Source code in <code>elkplot/shape_utils.py</code> <pre><code>@UNITS.wraps(None, (None, \"inch\", \"inch\", \"inch\", \"rad\"), False)\ndef rotate_and_scale_to_fit(\n    drawing: shapely.Geometry,\n    width: float,\n    height: float,\n    padding: float = 0,\n    increment: float = 0.02,\n) -&gt; shapely.Geometry:\n    \"\"\"\n    Fits a drawing into a bounding box of a given width and height, but unlike `scale_to_fit` also rotates the shape to\n    make it take up as much of that area as possible. Also centers the object in that bounding box\n    with the bounding box's upper-left corner at the origin.\n    Args:\n        drawing: The shapely geometry to rescale\n        width: The width of the bounding box in inches (or any other unit if you pass in a `pint.Quantity`.)\n        height: The height of the bounding box in inches (or any other unit if you pass in a `pint.Quantity`.)\n        padding: How much space to leave empty on all sides in inches (or any other unit if you pass in a `pint.Quantity`.)\n        increment: The gap between different rotation angles attempted in radians. (smaller value gives better results,\n            but larger values run faster.)\n\n    Returns:\n        A copy of the drawing having been rotated, rescaled, and moved such that the new upper-left corner of the\n            bounding box (including the padding) is at the origin\n\n    \"\"\"\n    best_geom: shapely.Geometry = drawing\n    biggest = 0\n    for angle in np.arange(0, np.pi, increment):\n        rotated = affinity.rotate(drawing, angle, use_radians=True)\n        scaled = scale_to_fit(rotated, width, height, padding)\n        w, h = size(scaled)\n        area = w * h\n        if area &gt; biggest:\n            best_geom = scaled\n            biggest = area\n    return best_geom\n</code></pre>"},{"location":"api_ref/making_art/#elkplot.shape_utils.scale_to_fit","title":"<code>scale_to_fit(drawing, width=0, height=0, padding=0)</code>","text":"<p>Scales a drawing up or down to perfectly fit into a given bounding box. Also centers the object in that bounding box with the bounding box's upper-left corner at the origin. Args:     drawing: The shapely geometry to rescale     width: The width of the bounding box in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)         If this is 0, the drawing will be scaled to fit into the given height with arbitrary width.     height: The height of the bounding box in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)         If this is 0, the drawing will be scaled to fit into the given width with arbitrary height.     padding: How much space to leave empty on all sides in inches (or any other unit if you pass in a         <code>pint.Quantity</code>.)</p> <p>Returns:</p> Type Description <code>Geometry</code> <p>A copy of the drawing having been rescaled and moved such that the new upper-left corner of the bounding</p> <code>Geometry</code> <p>box (including the padding) is at the origin</p> Source code in <code>elkplot/shape_utils.py</code> <pre><code>@UNITS.wraps(None, (None, \"inch\", \"inch\", \"inch\"), False)\ndef scale_to_fit(\n    drawing: shapely.Geometry,\n    width: float = 0,\n    height: float = 0,\n    padding: float = 0,\n) -&gt; shapely.Geometry:\n    \"\"\"\n    Scales a drawing up or down to perfectly fit into a given bounding box. Also centers the object in that bounding box\n    with the bounding box's upper-left corner at the origin.\n    Args:\n        drawing: The shapely geometry to rescale\n        width: The width of the bounding box in inches (or any other unit if you pass in a `pint.Quantity`.)\n            If this is 0, the drawing will be scaled to fit into the given height with arbitrary width.\n        height: The height of the bounding box in inches (or any other unit if you pass in a `pint.Quantity`.)\n            If this is 0, the drawing will be scaled to fit into the given width with arbitrary height.\n        padding: How much space to leave empty on all sides in inches (or any other unit if you pass in a\n            `pint.Quantity`.)\n\n    Returns:\n        A copy of the drawing having been rescaled and moved such that the new upper-left corner of the bounding\n        box (including the padding) is at the origin\n\n    \"\"\"\n    w, h = (dim.magnitude for dim in size(drawing))\n    if w == 0 or width == 0:\n        scale = (height - padding * 2) / h\n    elif h == 0 or height == 0:\n        scale = (width - padding * 2) / w\n    else:\n        scale = min((width - padding * 2) / w, (height - padding * 2) / h)\n    return center(affinity.scale(drawing, scale, scale), width, height)\n</code></pre>"},{"location":"api_ref/making_art/#elkplot.shape_utils.shade","title":"<code>shade(polygon, angle, spacing, offset=0.5)</code>","text":"<p>Fill in a shapely Polygon or MultiPolygon with parallel lines so that the plotter will fill in the shape with lines. Args:     polygon: The shape to be filled in     angle: The angle at which the parallel lines should travel in radians (or any other unit if you pass in a <code>pint.Quantity</code>.)     spacing: The gap between parallel lines in inches (or any other unit if you pass in a <code>pint.Quantity</code>.)     offset: How much should the parallel lines be shifted up or down as a percentage of the spacing?</p> <p>Returns:</p> Type Description <code>MultiLineString</code> <p>The MultiLineString of the shaded lines. (NOTE: Does not include the outline.)</p> Source code in <code>elkplot/shape_utils.py</code> <pre><code>@UNITS.wraps(None, (None, \"rad\", \"inch\", None), False)\ndef shade(\n    polygon: shapely.Polygon | shapely.MultiPolygon,\n    angle: float,\n    spacing: float,\n    offset: float = 0.5,\n) -&gt; shapely.MultiLineString:\n    \"\"\"\n    Fill in a shapely Polygon or MultiPolygon with parallel lines so that the plotter will fill in the shape with lines.\n    Args:\n        polygon: The shape to be filled in\n        angle: The angle at which the parallel lines should travel in radians (or any other unit if you pass in a `pint.Quantity`.)\n        spacing: The gap between parallel lines in inches (or any other unit if you pass in a `pint.Quantity`.)\n        offset: How much should the parallel lines be shifted up or down as a percentage of the spacing?\n\n    Returns:\n        The MultiLineString of the shaded lines. (NOTE: Does not include the outline.)\n\n    \"\"\"\n    polygon = affinity.rotate(\n        polygon, -angle, use_radians=True, origin=polygon.centroid\n    )\n    x0, y0, x1, y1 = polygon.bounds\n    shading = shapely.MultiLineString(\n        [[(x0, y), (x1, y)] for y in np.arange(y0 + offset * spacing, y1, spacing)]\n    )\n    shading = polygon.intersection(shading)\n    return affinity.rotate(shading, angle, use_radians=True, origin=polygon.centroid)\n</code></pre>"},{"location":"api_ref/making_art/#elkplot.shape_utils.size","title":"<code>size(geom)</code>","text":"<p>Calculate the width and height of the bounding box of a shapely geometry. Args:     geom: The shapely Geometry object to be measured</p> <p>Returns:</p> Type Description <code>Quantity</code> <p>width in inches</p> <code>Quantity</code> <p>height in inches</p> Source code in <code>elkplot/shape_utils.py</code> <pre><code>def size(geom: shapely.Geometry) -&gt; tuple[pint.Quantity, pint.Quantity]:\n    \"\"\"\n    Calculate the width and height of the bounding box of a shapely geometry.\n    Args:\n        geom: The shapely Geometry object to be measured\n\n    Returns:\n        width in inches\n        height in inches\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = geom.bounds\n    return (x_max - x_min) * UNITS.inch, (y_max - y_min) * UNITS.inch\n</code></pre>"},{"location":"api_ref/making_art/#elkplot.shape_utils.up_length","title":"<code>up_length(drawing)</code>","text":"<p>Calculate the total distance travelled by the pen while not in contact with the page. This can be improved by merging and/or reordering the paths using the <code>optimize</code> function. Args:     drawing: A single layer of plotter art</p> <p>Returns:</p> Type Description <code>Quantity</code> <p>The total pen-up distance in inches</p> Source code in <code>elkplot/shape_utils.py</code> <pre><code>def up_length(drawing: shapely.MultiLineString) -&gt; pint.Quantity:\n    \"\"\"\n    Calculate the total distance travelled by the pen while not in contact with the page.\n    This can be improved by merging and/or reordering the paths using the `optimize` function.\n    Args:\n        drawing: A single layer of plotter art\n\n    Returns:\n        The total pen-up distance in inches\n\n    \"\"\"\n    distance = 0\n    origin = shapely.points((0, 0))\n    pen_position = origin\n    for path in shapely.get_parts(drawing):\n        path_start, path_end = shapely.points(path.coords[0]), shapely.points(\n            path.coords[-1]\n        )\n        distance += shapely.distance(pen_position, path_start)\n        pen_position = path_end\n    return distance * UNITS.inch\n</code></pre>"},{"location":"api_ref/plotting/","title":"Plotting and Previewing","text":"<p>Most of the time, plotting is as simple as sending an appropriate shapely object to the <code>draw</code> function. See Making Art for more on how to create appropriate shapely geometry, but you are strongly encouraged to call <code>scale_to_fit()</code> and <code>optimize()</code> before plotting to make sure that your plot is the correct size for your page and the lines will be drawn in an order that doesn't waste a bunch of time with the pen in the air.</p>"},{"location":"api_ref/plotting/#elkplot.util.draw","title":"<code>draw(drawing, width=elkplot.sizes.A3[0], height=elkplot.sizes.A3[1], layer_labels=None, preview=True, preview_dpi=128, plot=True, retrace=1, device=None)</code>","text":"<p>Visualize and/or plot a given drawing. Automatically pauses the plotter between layers to allow for changing pens. Geometry can be given as a GeometryCollection (which will be treated as a multi-pen drawing), a list of geometries (in which case again, each will be treated as a separate pen), or any other shapely Geometry (which will be treated as a single layer.</p> <p>Parameters:</p> Name Type Description Default <code>drawing</code> <code>Geometry | list[Geometry]</code> <p>The shapely geometry to plot.</p> required <code>width</code> <code>float</code> <p>The width of the page in inches (or any other unit if you pass in a <code>pint.Quantity</code>.) Used only for the preview.</p> <code>A3[0]</code> <code>height</code> <code>float</code> <p>The height of the page in inches (or any other unit if you pass in a <code>pint.Quantity</code>.) Used only for the preview.</p> <code>A3[1]</code> <code>layer_labels</code> <code>Optional[list[str]]</code> <p>An ordered list of labels for each pen-layer. Used only to remind you what pen you should use when swapping pens between layers. If excluded, layers will just be numbered.</p> <code>None</code> <code>preview</code> <code>bool</code> <p>Should an on-screen preview of the plot be displayed?</p> <code>True</code> <code>preview_dpi</code> <code>float</code> <p>How big should the preview be? (Enter the DPI of your monitor to get an actual-size preview.)</p> <code>128</code> <code>plot</code> <code>bool</code> <p>Should the AxiDraw actually plot this? (If <code>preview</code> is <code>True</code>, plotting will only begin after the preview window is closed.)</p> <code>True</code> <code>retrace</code> <code>int</code> <p>How many times should the AxiDraw draw each line? If this is set to 2, it will draw a whole layer, then draw that layer a second time, then either finish or prompt you to change pens.</p> <code>1</code> <code>device</code> <code>Optional[Device]</code> <p>The AxiDraw config to which the plot should be sent. If excluded, a <code>Device</code> with all default settings will be used.</p> <code>None</code> Source code in <code>elkplot/util.py</code> <pre><code>@elkplot.UNITS.wraps(\n    None, (None, \"inch\", \"inch\", None, None, None, None, None, None), False\n)\ndef draw(\n    drawing: shapely.Geometry | list[shapely.Geometry],\n    width: float = elkplot.sizes.A3[0],\n    height: float = elkplot.sizes.A3[1],\n    layer_labels: Optional[list[str]] = None,\n    preview: bool = True,\n    preview_dpi: float = 128,\n    plot: bool = True,\n    retrace: int = 1,\n    device: Optional[elkplot.Device] = None,\n) -&gt; None:\n    \"\"\"\n    Visualize and/or plot a given drawing. Automatically pauses the plotter between layers to allow for changing pens.\n    Geometry can be given as a GeometryCollection (which will be treated as a multi-pen drawing), a list of geometries\n    (in which case again, each will be treated as a separate pen), or any other shapely Geometry (which will be treated\n    as a single layer.\n\n    Args:\n        drawing: The shapely geometry to plot.\n        width: The width of the page in inches (or any other unit if you pass in a `pint.Quantity`.) Used only for the\n            preview.\n        height: The height of the page in inches (or any other unit if you pass in a `pint.Quantity`.) Used only for the\n            preview.\n        layer_labels: An ordered list of labels for each pen-layer. Used only to remind you what pen you should use when\n            swapping pens between layers. If excluded, layers will just be numbered.\n        preview: Should an on-screen preview of the plot be displayed?\n        preview_dpi: How big should the preview be? (Enter the DPI of your monitor to get an actual-size preview.)\n        plot: Should the AxiDraw actually plot this? (If `preview` is `True`, plotting will only begin after the preview\n            window is closed.)\n        retrace: How many times should the AxiDraw draw each line? If this is set to 2, it will draw a whole layer, then\n            draw that layer a second time, then either finish or prompt you to change pens.\n        device: The AxiDraw config to which the plot should be sent. If excluded, a `Device` with all default settings\n            will be used.\n    \"\"\"\n    if isinstance(drawing, shapely.GeometryCollection):\n        layers = [\n            elkplot.flatten_geometry(layer) for layer in shapely.get_parts(drawing)\n        ]\n    elif isinstance(drawing, list):\n        layers = [elkplot.flatten_geometry(layer) for layer in drawing]\n    else:\n        layers = [elkplot.flatten_geometry(drawing)]\n    if layer_labels is None:\n        layer_labels = [f\"Layer #{i}\" for i in range(len(layers))]\n    else:\n        assert len(layer_labels) == len(layers)\n\n    min_x = min([layer.bounds[0] for layer in layers])\n    min_y = min([layer.bounds[1] for layer in layers])\n    max_x = max([layer.bounds[2] for layer in layers])\n    max_y = max([layer.bounds[3] for layer in layers])\n    out_of_bounds = min_x &lt; 0 or min_y &lt; 0 or max_x &gt; width or max_y &gt; height\n    if out_of_bounds:\n        warnings.warn(\"THIS DRAWING GOES OUT OF BOUNDS!\")\n\n    if preview:\n        elkplot.render(layers, width, height, preview_dpi)\n    if not plot:\n        return\n    min_x = min([layer.bounds[0] for layer in layers])\n    min_y = min([layer.bounds[1] for layer in layers])\n    max_x = max([layer.bounds[2] for layer in layers])\n    max_y = max([layer.bounds[3] for layer in layers])\n    if out_of_bounds:\n        raise DrawingOutOfBoundsError(\n            f\"Drawing has bounds ({min_x}, {min_y}) to ({max_x}, {max_y}), which extends outside the plottable bounds (0, 0) to ({width}, {height})\"\n        )\n    if not elkplot.device.axidraw_available():\n        raise AxidrawNotFoundError()\n    device = elkplot.Device() if device is None else device\n    device.zero_position()\n    device.enable_motors()\n    for layer, label in zip(layers, layer_labels):\n        input(f\"Press enter when you're ready to draw {label}\")\n        for _ in range(retrace):\n            device.run_layer(layer, label)\n    device.disable_motors()\n</code></pre>"},{"location":"api_ref/plotting/#managing-the-axidraw","title":"Managing the AxiDraw","text":"<p>The <code>draw</code> function above takes an optional Device as input. The device contains all the settings for how the AxiDraw actually goes about the business of plotting. This code was largely borrowed from the axi python library by Michael Fogleman. Generally speaking, I only pass Device objects to the draw function, but it also contains functions for directly controlling the AxiDraw.</p> <p>A common use case is slowing down the AxiDraw for pens that don't leave behind enough ink at the current speed. That would look something like this:</p> <pre><code>import shapely\nimport elkplot\n\ndrawing = shapely.MultiLineString([...])\ndevice = elkplot.Device(max_velocity=2)\nelkplot.draw(drawing, device=device)\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device","title":"<code>Device</code>","text":"Source code in <code>elkplot/device.py</code> <pre><code>class Device:\n    def __init__(\n        self,\n        pen_up_position: float = -50,\n        pen_down_position: float = -120,\n        pen_up_speed: float = 150,\n        pen_down_speed: float = 150,\n        pen_up_delay: int = 50,\n        pen_down_delay: int = 50,\n        acceleration: float = 16,\n        max_velocity: float = 4,\n        corner_factor: float = 0.001,\n        jog_acceleration: float = 16,\n        jog_max_velocity: float = 8,\n        pen_lift_pin: int = 2,\n        brushless: bool = True,\n    ):\n        \"\"\"\n        Construct a Device object that contains all the settings for the AxiDraw itself. The default values are chosen\n        based on what works for me and my AxiDraw with the upgraded brushless penlift motor - you may need to change\n        these for your AxiDraw.\n\n        Args:\n            pen_up_position: To what level should the pen be lifted? (I found this value by trial and error.)\n            pen_down_position: To what level should the pen be lowered? (I found this value by trial and error.)\n            pen_up_speed: How fast should the pen be lifted?\n            pen_down_speed: How fast should the pen be lowered?\n            pen_up_delay: How long (in ms) should the AxiDraw wait after starting to raise the pen before taking the\n                next action? (Lower is faster, but can lead to unwanted lines being drawn.)\n            pen_down_delay: How long (in ms) should the AxiDraw wait after starting to lower the pen before taking the\n                next action? (Lower is faster, but can lead to wanted lines not being drawn.)\n            acceleration: How aggressively should the AxiDraw accelerate up to `max_velocity`?\n            max_velocity: How fast should the AxiDraw move when traveling at top speed?\n            corner_factor: What is the radius of the corner when making a sharp turn? Larger values can\n                maintain higher speeds around corners, but will round off sharp edges. Smaller values are more accurate\n                to the original drawing but have to slow down more at sharp corners.\n            jog_acceleration: How aggressively should the AxiDraw accelerate up to `jog_max_velocity` when moving\n                while the pen is lifted?\n            jog_max_velocity: How fast should the AxiDraw move when traveling at top speed while the pen is lifted?\n            pen_lift_pin: To which pin on the driver board is the penlift motor connected? (Pin 0 is the bottom pin.)\n            brushless: Is the connected motor the upgraded brushless motor?\n        \"\"\"\n        self.timeslice_ms = 10\n        self.microstepping_mode = 1  # Maybe this will need to change someday? \ud83e\udd37\u200d\u2640\ufe0f\n        self.step_divider = 2 ** (self.microstepping_mode - 1)\n        self.steps_per_unit = 2032 / self.step_divider\n        self.steps_per_mm = 80 / self.step_divider\n        self.vid_pid = \"04d8:fd92\"  # ID common to all AxiDraws\n        self.pen_lift_pin = pen_lift_pin\n        self.brushless = brushless\n\n        self.pen_up_position = pen_up_position\n        self.pen_down_position = pen_down_position\n        self.pen_up_speed = pen_up_speed\n        self.pen_down_speed = pen_down_speed\n        self.pen_up_delay = pen_up_delay\n        self.pen_down_delay = pen_down_delay\n        self.acceleration = acceleration\n        self.max_velocity = max_velocity\n        self.corner_factor = corner_factor\n        self.jog_acceleration = jog_acceleration\n        self.jog_max_velocity = jog_max_velocity\n\n        self.error = (0, 0)  # accumulated step error\n\n        port = _find_port()\n        if port is None:\n            raise IOError(\"Could not connect to AxiDraw over USB\")\n        self.serial = Serial(port, timeout=1)\n        self._configure()\n\n    def _configure(self):\n        servo_max = 12600 if self.brushless else 27831  # Up at \"100%\" position.\n        servo_min = 5400 if not self.brushless else 9855  # Down at \"0%\" position\n\n        pen_up_position = self.pen_up_position / 100\n        pen_up_position = int(servo_min + (servo_max - servo_min) * pen_up_position)\n        pen_down_position = self.pen_down_position / 100\n        pen_down_position = int(servo_min + (servo_max - servo_min) * pen_down_position)\n        self._command(\"SC\", 4, pen_up_position)\n        self._command(\"SC\", 5, pen_down_position)\n        self._command(\"SC\", 11, int(self.pen_up_speed * 5))\n        self._command(\"SC\", 12, int(self.pen_down_speed * 5))\n\n    def close(self):\n        \"\"\"When you create a Device() object, it monopolizes access to that AxiDraw. Call this to free it up so other\n        programs can talk to it again.\"\"\"\n        self.serial.close()\n\n    def _make_planner(self, jog: bool = False) -&gt; Planner:\n        a = self.acceleration if not jog else self.jog_acceleration\n        vmax = self.max_velocity if not jog else self.jog_max_velocity\n        cf = self.corner_factor\n        return Planner(a, vmax, cf)\n\n    def _readline(self) -&gt; str:\n        return self.serial.readline().decode(\"utf-8\").strip()\n\n    def _command(self, *args) -&gt; str:\n        line = \",\".join(map(str, args))\n        self.serial.write((line + \"\\r\").encode(\"utf-8\"))\n        return self._readline()\n\n    # higher level functions\n    def move(self, dx: float, dy: float):\n        \"\"\"\n        Offset the current pen position.\n        Args:\n            dx: The offset in the x direction in inches\n            dy: The offset in the y direction in inches\n        \"\"\"\n        self.run_path(shapely.linestrings([(0, 0), (dx, dy)]))\n\n    def goto(self, x: float, y: float, jog: bool = True):\n        \"\"\"\n        Move the pen directly to a given point on the canvas. Points are measured in inches from the origin\n        Args:\n            x: The x-coordinate of the desired point\n            y: The y-coordinate of the desired point\n            jog: Should it travel at jog-speed or regular?\n        \"\"\"\n        # TODO: jog if pen up\n        px, py = self.read_position()\n        self.run_path(shapely.linestrings([(px, py), (x, y)]), jog=jog)\n\n    def home(self):\n        \"\"\"Send the pen back to (0, 0)\"\"\"\n        self.goto(0, 0, True)\n\n    # misc commands\n    def version(self):\n        return self._command(\"V\")\n\n    # motor functions\n    def enable_motors(self):\n        \"\"\"Turn the motors on\"\"\"\n        m = self.microstepping_mode\n        return self._command(\"EM\", m, m)\n\n    def disable_motors(self):\n        \"\"\"Turn the motors off\"\"\"\n        return self._command(\"EM\", 0, 0)\n\n    def motor_status(self):\n        return self._command(\"QM\")\n\n    def zero_position(self):\n        \"\"\"Set the current position of the pen as (0, 0). Called automatically when connecting to the device. For best\n        results, always start and end with the motor in home position. If necessary, though, you can disable motors,\n        manually reset the pen back home, and call this function.\"\"\"\n        return self._command(\"CS\")\n\n    def read_position(self) -&gt; tuple[float, float]:\n        \"\"\"Get the xy coordinates of the pen\"\"\"\n        response = self._command(\"QS\")\n        self._readline()\n        a, b = map(float, response.split(\",\"))\n        a /= self.steps_per_unit\n        b /= self.steps_per_unit\n        y = (a - b) / 2\n        x = y + b\n        return x, y\n\n    def stepper_move(self, duration: float, a, b):\n        return self._command(\"XM\", duration, a, b)\n\n    def wait(self):\n        while \"1\" in self.motor_status():\n            time.sleep(0.01)\n\n    def run_plan(self, plan: Plan):\n        step_s = self.timeslice_ms / 1000\n        t = 0\n        while t &lt; plan.t:\n            i1 = plan.instant(t)\n            i2 = plan.instant(t + step_s)\n            d = i2.p.sub(i1.p)\n            ex, ey = self.error\n            ex, sx = modf(d.x * self.steps_per_unit + ex)\n            ey, sy = modf(d.y * self.steps_per_unit + ey)\n            self.error = ex, ey\n            self.stepper_move(self.timeslice_ms, int(sx), int(sy))\n            t += step_s\n        # self.wait()\n\n    def run_path(self, path: shapely.LineString, draw: bool = False, jog: bool = False):\n        planner = self._make_planner(jog)\n        plan = planner.plan(list(path.coords))\n        if draw:\n            self.pen_down()\n            self.run_plan(plan)\n            self.pen_up()\n        else:\n            self.run_plan(plan)\n\n    def run_layer(self, layer: shapely.MultiLineString, label: str = None):\n        jog_planner = self._make_planner(True)\n        draw_planner = self._make_planner(False)\n        queue = mp.Queue()\n        layer_coord_list = [list(line.coords) for line in shapely.get_parts(layer)]\n        p = mp.Process(\n            target=plan_layer_proc,\n            args=(queue, layer_coord_list, jog_planner, draw_planner),\n        )\n        p.start()\n        bar = tqdm(total=layer.length + elkplot.up_length(layer).m, desc=label)\n        idx = 0\n        while True:\n            jog_plan, length = queue.get()\n            if jog_plan == \"DONE\":\n                break\n            if idx % 2 == 0:\n                self.pen_up()\n            else:\n                self.pen_down()\n            self.run_plan(jog_plan)\n            bar.update(length)\n            idx += 1\n        bar.close()\n        self.pen_up()\n        self.home()\n\n    # pen functions\n    def pen_up(self):\n        \"\"\"Lift the pen\"\"\"\n        return self._command(\"SP\", 1, self.pen_up_delay, self.pen_lift_pin)\n\n    def pen_down(self):\n        \"\"\"Lower the pen\"\"\"\n        return self._command(\"SP\", 0, self.pen_down_delay, self.pen_lift_pin)\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.__init__","title":"<code>__init__(pen_up_position=-50, pen_down_position=-120, pen_up_speed=150, pen_down_speed=150, pen_up_delay=50, pen_down_delay=50, acceleration=16, max_velocity=4, corner_factor=0.001, jog_acceleration=16, jog_max_velocity=8, pen_lift_pin=2, brushless=True)</code>","text":"<p>Construct a Device object that contains all the settings for the AxiDraw itself. The default values are chosen based on what works for me and my AxiDraw with the upgraded brushless penlift motor - you may need to change these for your AxiDraw.</p> <p>Parameters:</p> Name Type Description Default <code>pen_up_position</code> <code>float</code> <p>To what level should the pen be lifted? (I found this value by trial and error.)</p> <code>-50</code> <code>pen_down_position</code> <code>float</code> <p>To what level should the pen be lowered? (I found this value by trial and error.)</p> <code>-120</code> <code>pen_up_speed</code> <code>float</code> <p>How fast should the pen be lifted?</p> <code>150</code> <code>pen_down_speed</code> <code>float</code> <p>How fast should the pen be lowered?</p> <code>150</code> <code>pen_up_delay</code> <code>int</code> <p>How long (in ms) should the AxiDraw wait after starting to raise the pen before taking the next action? (Lower is faster, but can lead to unwanted lines being drawn.)</p> <code>50</code> <code>pen_down_delay</code> <code>int</code> <p>How long (in ms) should the AxiDraw wait after starting to lower the pen before taking the next action? (Lower is faster, but can lead to wanted lines not being drawn.)</p> <code>50</code> <code>acceleration</code> <code>float</code> <p>How aggressively should the AxiDraw accelerate up to <code>max_velocity</code>?</p> <code>16</code> <code>max_velocity</code> <code>float</code> <p>How fast should the AxiDraw move when traveling at top speed?</p> <code>4</code> <code>corner_factor</code> <code>float</code> <p>What is the radius of the corner when making a sharp turn? Larger values can maintain higher speeds around corners, but will round off sharp edges. Smaller values are more accurate to the original drawing but have to slow down more at sharp corners.</p> <code>0.001</code> <code>jog_acceleration</code> <code>float</code> <p>How aggressively should the AxiDraw accelerate up to <code>jog_max_velocity</code> when moving while the pen is lifted?</p> <code>16</code> <code>jog_max_velocity</code> <code>float</code> <p>How fast should the AxiDraw move when traveling at top speed while the pen is lifted?</p> <code>8</code> <code>pen_lift_pin</code> <code>int</code> <p>To which pin on the driver board is the penlift motor connected? (Pin 0 is the bottom pin.)</p> <code>2</code> <code>brushless</code> <code>bool</code> <p>Is the connected motor the upgraded brushless motor?</p> <code>True</code> Source code in <code>elkplot/device.py</code> <pre><code>def __init__(\n    self,\n    pen_up_position: float = -50,\n    pen_down_position: float = -120,\n    pen_up_speed: float = 150,\n    pen_down_speed: float = 150,\n    pen_up_delay: int = 50,\n    pen_down_delay: int = 50,\n    acceleration: float = 16,\n    max_velocity: float = 4,\n    corner_factor: float = 0.001,\n    jog_acceleration: float = 16,\n    jog_max_velocity: float = 8,\n    pen_lift_pin: int = 2,\n    brushless: bool = True,\n):\n    \"\"\"\n    Construct a Device object that contains all the settings for the AxiDraw itself. The default values are chosen\n    based on what works for me and my AxiDraw with the upgraded brushless penlift motor - you may need to change\n    these for your AxiDraw.\n\n    Args:\n        pen_up_position: To what level should the pen be lifted? (I found this value by trial and error.)\n        pen_down_position: To what level should the pen be lowered? (I found this value by trial and error.)\n        pen_up_speed: How fast should the pen be lifted?\n        pen_down_speed: How fast should the pen be lowered?\n        pen_up_delay: How long (in ms) should the AxiDraw wait after starting to raise the pen before taking the\n            next action? (Lower is faster, but can lead to unwanted lines being drawn.)\n        pen_down_delay: How long (in ms) should the AxiDraw wait after starting to lower the pen before taking the\n            next action? (Lower is faster, but can lead to wanted lines not being drawn.)\n        acceleration: How aggressively should the AxiDraw accelerate up to `max_velocity`?\n        max_velocity: How fast should the AxiDraw move when traveling at top speed?\n        corner_factor: What is the radius of the corner when making a sharp turn? Larger values can\n            maintain higher speeds around corners, but will round off sharp edges. Smaller values are more accurate\n            to the original drawing but have to slow down more at sharp corners.\n        jog_acceleration: How aggressively should the AxiDraw accelerate up to `jog_max_velocity` when moving\n            while the pen is lifted?\n        jog_max_velocity: How fast should the AxiDraw move when traveling at top speed while the pen is lifted?\n        pen_lift_pin: To which pin on the driver board is the penlift motor connected? (Pin 0 is the bottom pin.)\n        brushless: Is the connected motor the upgraded brushless motor?\n    \"\"\"\n    self.timeslice_ms = 10\n    self.microstepping_mode = 1  # Maybe this will need to change someday? \ud83e\udd37\u200d\u2640\ufe0f\n    self.step_divider = 2 ** (self.microstepping_mode - 1)\n    self.steps_per_unit = 2032 / self.step_divider\n    self.steps_per_mm = 80 / self.step_divider\n    self.vid_pid = \"04d8:fd92\"  # ID common to all AxiDraws\n    self.pen_lift_pin = pen_lift_pin\n    self.brushless = brushless\n\n    self.pen_up_position = pen_up_position\n    self.pen_down_position = pen_down_position\n    self.pen_up_speed = pen_up_speed\n    self.pen_down_speed = pen_down_speed\n    self.pen_up_delay = pen_up_delay\n    self.pen_down_delay = pen_down_delay\n    self.acceleration = acceleration\n    self.max_velocity = max_velocity\n    self.corner_factor = corner_factor\n    self.jog_acceleration = jog_acceleration\n    self.jog_max_velocity = jog_max_velocity\n\n    self.error = (0, 0)  # accumulated step error\n\n    port = _find_port()\n    if port is None:\n        raise IOError(\"Could not connect to AxiDraw over USB\")\n    self.serial = Serial(port, timeout=1)\n    self._configure()\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.close","title":"<code>close()</code>","text":"<p>When you create a Device() object, it monopolizes access to that AxiDraw. Call this to free it up so other programs can talk to it again.</p> Source code in <code>elkplot/device.py</code> <pre><code>def close(self):\n    \"\"\"When you create a Device() object, it monopolizes access to that AxiDraw. Call this to free it up so other\n    programs can talk to it again.\"\"\"\n    self.serial.close()\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.disable_motors","title":"<code>disable_motors()</code>","text":"<p>Turn the motors off</p> Source code in <code>elkplot/device.py</code> <pre><code>def disable_motors(self):\n    \"\"\"Turn the motors off\"\"\"\n    return self._command(\"EM\", 0, 0)\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.enable_motors","title":"<code>enable_motors()</code>","text":"<p>Turn the motors on</p> Source code in <code>elkplot/device.py</code> <pre><code>def enable_motors(self):\n    \"\"\"Turn the motors on\"\"\"\n    m = self.microstepping_mode\n    return self._command(\"EM\", m, m)\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.goto","title":"<code>goto(x, y, jog=True)</code>","text":"<p>Move the pen directly to a given point on the canvas. Points are measured in inches from the origin Args:     x: The x-coordinate of the desired point     y: The y-coordinate of the desired point     jog: Should it travel at jog-speed or regular?</p> Source code in <code>elkplot/device.py</code> <pre><code>def goto(self, x: float, y: float, jog: bool = True):\n    \"\"\"\n    Move the pen directly to a given point on the canvas. Points are measured in inches from the origin\n    Args:\n        x: The x-coordinate of the desired point\n        y: The y-coordinate of the desired point\n        jog: Should it travel at jog-speed or regular?\n    \"\"\"\n    # TODO: jog if pen up\n    px, py = self.read_position()\n    self.run_path(shapely.linestrings([(px, py), (x, y)]), jog=jog)\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.home","title":"<code>home()</code>","text":"<p>Send the pen back to (0, 0)</p> Source code in <code>elkplot/device.py</code> <pre><code>def home(self):\n    \"\"\"Send the pen back to (0, 0)\"\"\"\n    self.goto(0, 0, True)\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.move","title":"<code>move(dx, dy)</code>","text":"<p>Offset the current pen position. Args:     dx: The offset in the x direction in inches     dy: The offset in the y direction in inches</p> Source code in <code>elkplot/device.py</code> <pre><code>def move(self, dx: float, dy: float):\n    \"\"\"\n    Offset the current pen position.\n    Args:\n        dx: The offset in the x direction in inches\n        dy: The offset in the y direction in inches\n    \"\"\"\n    self.run_path(shapely.linestrings([(0, 0), (dx, dy)]))\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.pen_down","title":"<code>pen_down()</code>","text":"<p>Lower the pen</p> Source code in <code>elkplot/device.py</code> <pre><code>def pen_down(self):\n    \"\"\"Lower the pen\"\"\"\n    return self._command(\"SP\", 0, self.pen_down_delay, self.pen_lift_pin)\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.pen_up","title":"<code>pen_up()</code>","text":"<p>Lift the pen</p> Source code in <code>elkplot/device.py</code> <pre><code>def pen_up(self):\n    \"\"\"Lift the pen\"\"\"\n    return self._command(\"SP\", 1, self.pen_up_delay, self.pen_lift_pin)\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.read_position","title":"<code>read_position()</code>","text":"<p>Get the xy coordinates of the pen</p> Source code in <code>elkplot/device.py</code> <pre><code>def read_position(self) -&gt; tuple[float, float]:\n    \"\"\"Get the xy coordinates of the pen\"\"\"\n    response = self._command(\"QS\")\n    self._readline()\n    a, b = map(float, response.split(\",\"))\n    a /= self.steps_per_unit\n    b /= self.steps_per_unit\n    y = (a - b) / 2\n    x = y + b\n    return x, y\n</code></pre>"},{"location":"api_ref/plotting/#elkplot.device.Device.zero_position","title":"<code>zero_position()</code>","text":"<p>Set the current position of the pen as (0, 0). Called automatically when connecting to the device. For best results, always start and end with the motor in home position. If necessary, though, you can disable motors, manually reset the pen back home, and call this function.</p> Source code in <code>elkplot/device.py</code> <pre><code>def zero_position(self):\n    \"\"\"Set the current position of the pen as (0, 0). Called automatically when connecting to the device. For best\n    results, always start and end with the motor in home position. If necessary, though, you can disable motors,\n    manually reset the pen back home, and call this function.\"\"\"\n    return self._command(\"CS\")\n</code></pre>"},{"location":"api_ref/text/","title":"Rendering Text!","text":"<p>elkplot can render text in a number of different fonts using the built in <code>text</code> function. Here are all the provided fonts plotted on letter paper:</p> <p></p> <p>The full list of fonts as you'd use them in code are: <code>elkplot.ASTROLOGY, elkplot.CURSIVE, elkplot.CYRILLIC_1, elkplot.CYRILLIC, elkplot.FUTURAL, elkplot.FUTURAM, elkplot.GOTHGBT, elkplot.GOTHGRT, elkplot.GOTHICENG, elkplot.GOTHICGER, elkplot.GOTHICITA, elkplot.GOTHITT, elkplot.GREEK, elkplot.GREEKC, elkplot.GREEKS, elkplot.JAPANESE, elkplot.MARKERS, elkplot.MATHLOW, elkplot.MATHUPP, elkplot.METEOROLOGY, elkplot.MUSIC, elkplot.ROWMAND, elkplot.ROWMANS, elkplot.ROWMANT, elkplot.SCRIPTC, elkplot.SCRIPTS, elkplot.SYMBOLIC, elkplot.TIMESG, elkplot.TIMESI, elkplot.TIMESIB, elkplot.TIMESR, elkplot.TIMESRB</code>.</p>"},{"location":"api_ref/text/#sample-code","title":"Sample Code","text":"<pre><code>import elkplot\n\nsize = 4 * elkplot.UNITS.inch, 2 * elkplot.UNITS.inch\nfont = elkplot.Font(elkplot.METEOROLOGY, 25)\ntext_drawing = font.wrap(\"The quick brown fox jumps over the lazy dog.\", 3)\ntext_drawing = elkplot.center(text_drawing, *size)\nelkplot.draw(text_drawing, *size, plot=False)\n</code></pre> <p>The above code results in the following plot (as viewed in the preview window). The paper is 4 inches wide, but the text has been wrapped to fit in a column 3 inches wide. </p> <p>Note that all the text generating functions return text that is situated at the origin - use functions like <code>elkplot.center()</code> or <code>elkplot.scale_to_fit()</code> to move and scale your text-drawing or use <code>shapely.affinity.translate()</code> to reposition the text-drawing to arbitrary positions.</p>"},{"location":"api_ref/text/#elkplot.text.hershey.Font","title":"<code>Font</code>","text":"Source code in <code>elkplot/text/hershey.py</code> <pre><code>class Font:\n    def __init__(self, font: HersheyFont, point_size: float):\n        \"\"\"A class that renders text in a given font and point size\"\"\"\n        self.font = font\n        self.max_height = size(text(printable, font))[1]\n        self.scale = ((point_size / 72) / self.max_height).magnitude\n\n    def text(self, string: str) -&gt; shapely.MultiLineString:\n        \"\"\"\n        Render a string using this font's size and font in a single long line.\n        Args:\n            string: The text to be rendered\n\n        Returns:\n            The drawing of the text\n\n        \"\"\"\n        t = text(string, self.font)\n        t = affinity.scale(t, self.scale, self.scale, origin=(0, 0))\n        return t\n\n    def measure(self, string: str) -&gt; tuple[pint.Quantity, pint.Quantity]:\n        \"\"\"Return the width and height of a given string rendered using this font/size combo\"\"\"\n        t = self.text(string)\n        return size(t)\n\n    @elkplot.UNITS.wraps(None, [None, None, \"inch\", None, None], False)\n    def wrap(\n            self,\n            string: str,\n            width: float,\n            line_spacing: float = 1,\n            align: float = 0,\n    ) -&gt; shapely.MultiLineString:\n        \"\"\"\n        Render a given string such that the text is confined to a column of a given width by inserting line breaks.\n        Args:\n            string: The text to be rendered\n            width: The width of the column\n            line_spacing: A multiplier on the gap between lines. Setting this to 0.5 would cut the space between lines\n                in half, and setting this to 2 would double the space between lines.\n            align: 0=align text left, 1=align text right, 2=align text center\n\n        Returns:\n            The drawing of the text\n\n        \"\"\"\n        lines = word_wrap(string, width, self.measure)\n        line_shapes = [self.text(line) for line in lines]\n        max_width = max(size(t)[0] for t in line_shapes)\n        spacing = line_spacing * self.max_height * self.scale\n        result = []\n        y = 0\n        for line_shape in line_shapes:\n            w, h = size(line_shape)\n            if align == 0:\n                x = 0\n            elif align == 1:\n                x = (max_width - w).m\n            else:\n                x = (max_width / 2 - w / 2).m\n            line_shape = affinity.translate(line_shape, x, y)\n            result.append(line_shape)\n            y += spacing.m\n        return shapely.union_all(result)\n</code></pre>"},{"location":"api_ref/text/#elkplot.text.hershey.Font.__init__","title":"<code>__init__(font, point_size)</code>","text":"<p>A class that renders text in a given font and point size</p> Source code in <code>elkplot/text/hershey.py</code> <pre><code>def __init__(self, font: HersheyFont, point_size: float):\n    \"\"\"A class that renders text in a given font and point size\"\"\"\n    self.font = font\n    self.max_height = size(text(printable, font))[1]\n    self.scale = ((point_size / 72) / self.max_height).magnitude\n</code></pre>"},{"location":"api_ref/text/#elkplot.text.hershey.Font.measure","title":"<code>measure(string)</code>","text":"<p>Return the width and height of a given string rendered using this font/size combo</p> Source code in <code>elkplot/text/hershey.py</code> <pre><code>def measure(self, string: str) -&gt; tuple[pint.Quantity, pint.Quantity]:\n    \"\"\"Return the width and height of a given string rendered using this font/size combo\"\"\"\n    t = self.text(string)\n    return size(t)\n</code></pre>"},{"location":"api_ref/text/#elkplot.text.hershey.Font.text","title":"<code>text(string)</code>","text":"<p>Render a string using this font's size and font in a single long line. Args:     string: The text to be rendered</p> <p>Returns:</p> Type Description <code>MultiLineString</code> <p>The drawing of the text</p> Source code in <code>elkplot/text/hershey.py</code> <pre><code>def text(self, string: str) -&gt; shapely.MultiLineString:\n    \"\"\"\n    Render a string using this font's size and font in a single long line.\n    Args:\n        string: The text to be rendered\n\n    Returns:\n        The drawing of the text\n\n    \"\"\"\n    t = text(string, self.font)\n    t = affinity.scale(t, self.scale, self.scale, origin=(0, 0))\n    return t\n</code></pre>"},{"location":"api_ref/text/#elkplot.text.hershey.Font.wrap","title":"<code>wrap(string, width, line_spacing=1, align=0)</code>","text":"<p>Render a given string such that the text is confined to a column of a given width by inserting line breaks. Args:     string: The text to be rendered     width: The width of the column     line_spacing: A multiplier on the gap between lines. Setting this to 0.5 would cut the space between lines         in half, and setting this to 2 would double the space between lines.     align: 0=align text left, 1=align text right, 2=align text center</p> <p>Returns:</p> Type Description <code>MultiLineString</code> <p>The drawing of the text</p> Source code in <code>elkplot/text/hershey.py</code> <pre><code>@elkplot.UNITS.wraps(None, [None, None, \"inch\", None, None], False)\ndef wrap(\n        self,\n        string: str,\n        width: float,\n        line_spacing: float = 1,\n        align: float = 0,\n) -&gt; shapely.MultiLineString:\n    \"\"\"\n    Render a given string such that the text is confined to a column of a given width by inserting line breaks.\n    Args:\n        string: The text to be rendered\n        width: The width of the column\n        line_spacing: A multiplier on the gap between lines. Setting this to 0.5 would cut the space between lines\n            in half, and setting this to 2 would double the space between lines.\n        align: 0=align text left, 1=align text right, 2=align text center\n\n    Returns:\n        The drawing of the text\n\n    \"\"\"\n    lines = word_wrap(string, width, self.measure)\n    line_shapes = [self.text(line) for line in lines]\n    max_width = max(size(t)[0] for t in line_shapes)\n    spacing = line_spacing * self.max_height * self.scale\n    result = []\n    y = 0\n    for line_shape in line_shapes:\n        w, h = size(line_shape)\n        if align == 0:\n            x = 0\n        elif align == 1:\n            x = (max_width - w).m\n        else:\n            x = (max_width / 2 - w / 2).m\n        line_shape = affinity.translate(line_shape, x, y)\n        result.append(line_shape)\n        y += spacing.m\n    return shapely.union_all(result)\n</code></pre>"},{"location":"api_ref/turtle/","title":"Turtle Graphics \ud83d\udc22","text":""},{"location":"api_ref/turtle/#explanation-example","title":"Explanation &amp; Example","text":"<p>ElkPlot includes a recreation of Logo's turtle graphics. This is intended as a quick and easy way for learners to start making art without having to go too deep on the Python programming language. (Yet)</p> <p>Getting started is super easy - just make a turtle and give it some instructions. You can name your turtle whatever you like - I decided to name mine Gamera.</p> <pre><code>import elkplot\n\ndef main():\n    w, h = elkplot.sizes.LETTER\n\n    # the turtle starts at (0, 0) facing right\n    gamera = elkplot.Turtle(use_degrees=True)\n\n    # draw the left eye\n    gamera.turn_right(90)\n    gamera.forward(2)\n    gamera.raise_pen()\n\n    # draw the right eye\n    gamera.goto(2, 0)\n    gamera.lower_pen()\n    gamera.forward(2)\n    gamera.raise_pen()\n\n    # draw the mouth\n    gamera.goto(-1.5, 2.5)\n    gamera.lower_pen()\n    gamera.turn_left(45)\n    gamera.forward(1.5)\n    gamera.turn_left(45)\n    gamera.forward(3)\n    gamera.turn_left(45)\n    gamera.forward(1.5)\n\n    # render the drawing, center it on a letter size sheet, and draw\n    d = gamera.drawing() \n    d = elkplot.center(d, w, h)\n    elkplot.draw(d, w, h, plot=False)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p></p>"},{"location":"api_ref/turtle/#checkpoint","title":"Checkpoint!","text":"<p>You can use a checkpoint context to return to your current position and rotation upon exiting the context. The following tree fractal uses checkpoints to return to the base of a branch once finishing drawing that branch.</p> <pre><code>import elkplot\n\n\ndef tree(\n    angle: float, length: float, shrink: float, depth: int, turtle: elkplot.Turtle\n) -&gt; None:\n    if depth &lt;= 0:\n        return\n    turtle.forward(length)\n    with turtle.checkpoint():\n        turtle.turn(-angle)\n        tree(angle, shrink * length, shrink, depth - 1, turtle)\n    with turtle.checkpoint():\n        turtle.turn(angle)\n        tree(angle, shrink * length, shrink, depth - 1, turtle)\n\n\ndef main():\n    w, h, margin = 8, 8, 0.5\n    turtle = elkplot.Turtle(use_degrees=True)\n    turtle.turn_left(90)\n    tree(20, 1, 0.8, 10, turtle)\n    drawing = turtle.drawing()\n    drawing = elkplot.scale_to_fit(drawing, w, h, margin)\n    elkplot.draw(drawing, w, h, plot=False)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p></p>"},{"location":"api_ref/turtle/#full-reference","title":"Full Reference","text":""},{"location":"api_ref/turtle/#elkplot.turtle.Turtle","title":"<code>Turtle</code>","text":"Source code in <code>elkplot/turtle.py</code> <pre><code>class Turtle:\n    def __init__(\n        self, x: float = 0, y: float = 0, heading: float = 0, use_degrees=False\n    ) -&gt; None:\n        \"\"\"Create a new turtle!\n\n        Args:\n            x (float, optional): x-coordinate of the turtle's starting position. Defaults to 0.\n            y (float, optional): y-coordinate of the turtle's starting position. Defaults to 0.\n            heading (float, optional): Direction the turtle is pointing. Defaults to 0.\n            use_degrees (bool, optional): Should angles be given in radians or degrees? Defaults to False.\n        \"\"\"\n        self._state = TurtleState(shapely.Point(x, y), heading, True)\n        self._stack: list[TurtleState] = []\n        self._current_line: list[shapely.Point] = [self.position]\n        self._lines: list[shapely.LineString] = []\n        self._use_degrees = use_degrees\n\n    @property\n    def heading(self) -&gt; float:\n        \"\"\"\n        Returns:\n            float: Which way is the turtle facing?\n        \"\"\"\n        if self._use_degrees:\n            return self._state.heading * RAD_TO_DEG\n        return self._state.heading\n\n    @property\n    def heading_rad(self) -&gt; float:\n        return self._state.heading\n\n    @property\n    def position(self) -&gt; shapely.Point:\n        \"\"\"\n        Returns:\n            shapely.Point: Where is the turtle right now?\n        \"\"\"\n        return self._state.position\n\n    @property\n    def x(self) -&gt; float:\n        \"\"\"\n        Returns:\n            float: The turtle's x-coordinate\n        \"\"\"\n        return self._state.position.x\n\n    @property\n    def y(self) -&gt; float:\n        \"\"\"\n        Returns:\n            float: The turtle's y-coordinate\n        \"\"\"\n        return self._state.position.y\n\n    @property\n    def pen_down(self) -&gt; bool:\n        \"\"\"\n        Returns:\n            bool: Is the turtle drawing currently\n        \"\"\"\n        return self._state.pen_down\n\n    def forward(self, distance: float) -&gt; Turtle:\n        \"\"\"Move the turtle forward by some distance. You can also move the turtle\n          backwards by calling this function with a negative input\n\n        Args:\n            distance (float): The distance to move forward\n\n        Returns:\n            Turtle: Return self so that commands can be chained\n        \"\"\"\n        dx, dy = distance * np.cos(self.heading_rad), distance * np.sin(\n            self.heading_rad\n        )\n        return self.goto(self.x + dx, self.y + dy)\n\n    def backward(self, distance: float) -&gt; Turtle:\n        \"\"\"Move the turtle backward by some distance.\n\n        Args:\n            distance (float): The distance to move backward\n\n        Returns:\n            Turtle: Return self so that commands can be chained\n        \"\"\"\n        return self.forward(-distance)\n\n    def turn(self, angle: float) -&gt; Turtle:\n        \"\"\"Rotate clockwise by some angle. To rotate counterclockwise, pass a negative angle.\n\n        Args:\n            angle (float): The angle by which to rotate\n\n        Returns:\n            Turtle: Return self so that commands can be chained\n        \"\"\"\n        return self.turn_right(angle)\n\n    def turn_right(self, angle: float) -&gt; Turtle:\n        \"\"\"Rotate clockwise by some angle. (This is an alias for turn)\n\n        Args:\n            angle (float): The angle by which to rotate\n\n        Returns:\n            Turtle: Return self so that commands can be chained\n        \"\"\"\n        new_heading = self.heading_rad + angle * (\n            DEG_TO_RAD if self._use_degrees else 1\n        )\n        self._state = dataclasses.replace(self._state, heading=new_heading)\n        return self\n\n    def turn_left(self, angle: float) -&gt; Turtle:\n        \"\"\"Rotate anti-clockwise by some angle.\n\n        Args:\n            angle (float): The angle by which to rotate\n\n        Returns:\n            Turtle: Return self so that commands can be chained\n        \"\"\"\n        return self.turn_right(-angle)\n\n    def goto(self, x: float, y: float) -&gt; Turtle:\n        \"\"\"Move the turtle directly to a given coordinate\n\n        Args:\n            x (float): The x-coordinate of the point to which to go\n            y (float): The y-coordinate of the point to which to go\n\n        Returns:\n            Turtle: Return self so that commands can be chained\n        \"\"\"\n        new_pos = shapely.Point(x, y)\n        if self.pen_down:\n            self._current_line.append(new_pos)\n        self._state = dataclasses.replace(self._state, position=new_pos)\n        return self\n\n    def raise_pen(self) -&gt; Turtle:\n        \"\"\"Lift the pen so that lines are not created when the turtle moves\n\n        Returns:\n            Turtle: Return self so that commands can be chained\n        \"\"\"\n        if len(self._current_line) &gt; 1:\n            self._lines.append(shapely.LineString(self._current_line))\n        self._current_line = [self.position]\n        self._state = dataclasses.replace(self._state, pen_down=False)\n        return self\n\n    def lower_pen(self) -&gt; Turtle:\n        \"\"\"Lower the pen so that lines are created when the turtle moves\n\n        Returns:\n            Turtle: Return self so that commands can be chained\n        \"\"\"\n        self._current_line = [self.position]\n        self._state = dataclasses.replace(self._state, pen_down=True)\n        return self\n\n    def push(self) -&gt; Turtle:\n        \"\"\"Push the turtle's current state (position &amp; angle) onto a stack\n        so that the turtle can revert to that position later\n\n        Returns:\n            Turtle: Return self so that commands can be chained\n        \"\"\"\n        self._stack.append(self._state)\n        return self\n\n    def pop(self) -&gt; Turtle:\n        \"\"\"Pop the top state from the stack and revert the turtle to that state.\n        New lines are not created by the turtle jumping back to this old state.\n\n        Returns:\n            Turtle: Return self so that commands can be chained\n        \"\"\"\n        self.raise_pen()\n        self._state = self._stack.pop()\n        if self.pen_down:\n            self._current_line = [self.position]\n        return self\n\n    def drawing(self) -&gt; shapely.MultiLineString:\n        \"\"\"Turn the paths drawn by the turtle into a shapely geometry so that it\n        can be further modified or plotted.\n\n        Returns:\n            shapely.MultiLineString: The MultiLineString composed from all the lines the turtle drew.\n        \"\"\"\n        if self.pen_down:\n            self.raise_pen()\n            self.lower_pen()\n        return shapely.MultiLineString(self._lines)\n\n    def checkpoint(self) -&gt; TurtleCheckpoint:\n        \"\"\"Allows for pushing and popping as part of a context using the `with` keyword.\"\"\"\n        return TurtleCheckpoint(self)\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.heading","title":"<code>heading: float</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Which way is the turtle facing?</p>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.pen_down","title":"<code>pen_down: bool</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Is the turtle drawing currently</p>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.position","title":"<code>position: shapely.Point</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Point</code> <p>shapely.Point: Where is the turtle right now?</p>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.x","title":"<code>x: float</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The turtle's x-coordinate</p>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.y","title":"<code>y: float</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The turtle's y-coordinate</p>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.__init__","title":"<code>__init__(x=0, y=0, heading=0, use_degrees=False)</code>","text":"<p>Create a new turtle!</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x-coordinate of the turtle's starting position. Defaults to 0.</p> <code>0</code> <code>y</code> <code>float</code> <p>y-coordinate of the turtle's starting position. Defaults to 0.</p> <code>0</code> <code>heading</code> <code>float</code> <p>Direction the turtle is pointing. Defaults to 0.</p> <code>0</code> <code>use_degrees</code> <code>bool</code> <p>Should angles be given in radians or degrees? Defaults to False.</p> <code>False</code> Source code in <code>elkplot/turtle.py</code> <pre><code>def __init__(\n    self, x: float = 0, y: float = 0, heading: float = 0, use_degrees=False\n) -&gt; None:\n    \"\"\"Create a new turtle!\n\n    Args:\n        x (float, optional): x-coordinate of the turtle's starting position. Defaults to 0.\n        y (float, optional): y-coordinate of the turtle's starting position. Defaults to 0.\n        heading (float, optional): Direction the turtle is pointing. Defaults to 0.\n        use_degrees (bool, optional): Should angles be given in radians or degrees? Defaults to False.\n    \"\"\"\n    self._state = TurtleState(shapely.Point(x, y), heading, True)\n    self._stack: list[TurtleState] = []\n    self._current_line: list[shapely.Point] = [self.position]\n    self._lines: list[shapely.LineString] = []\n    self._use_degrees = use_degrees\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.backward","title":"<code>backward(distance)</code>","text":"<p>Move the turtle backward by some distance.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance to move backward</p> required <p>Returns:</p> Name Type Description <code>Turtle</code> <code>Turtle</code> <p>Return self so that commands can be chained</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def backward(self, distance: float) -&gt; Turtle:\n    \"\"\"Move the turtle backward by some distance.\n\n    Args:\n        distance (float): The distance to move backward\n\n    Returns:\n        Turtle: Return self so that commands can be chained\n    \"\"\"\n    return self.forward(-distance)\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.checkpoint","title":"<code>checkpoint()</code>","text":"<p>Allows for pushing and popping as part of a context using the <code>with</code> keyword.</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def checkpoint(self) -&gt; TurtleCheckpoint:\n    \"\"\"Allows for pushing and popping as part of a context using the `with` keyword.\"\"\"\n    return TurtleCheckpoint(self)\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.drawing","title":"<code>drawing()</code>","text":"<p>Turn the paths drawn by the turtle into a shapely geometry so that it can be further modified or plotted.</p> <p>Returns:</p> Type Description <code>MultiLineString</code> <p>shapely.MultiLineString: The MultiLineString composed from all the lines the turtle drew.</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def drawing(self) -&gt; shapely.MultiLineString:\n    \"\"\"Turn the paths drawn by the turtle into a shapely geometry so that it\n    can be further modified or plotted.\n\n    Returns:\n        shapely.MultiLineString: The MultiLineString composed from all the lines the turtle drew.\n    \"\"\"\n    if self.pen_down:\n        self.raise_pen()\n        self.lower_pen()\n    return shapely.MultiLineString(self._lines)\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.forward","title":"<code>forward(distance)</code>","text":"<p>Move the turtle forward by some distance. You can also move the turtle   backwards by calling this function with a negative input</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance to move forward</p> required <p>Returns:</p> Name Type Description <code>Turtle</code> <code>Turtle</code> <p>Return self so that commands can be chained</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def forward(self, distance: float) -&gt; Turtle:\n    \"\"\"Move the turtle forward by some distance. You can also move the turtle\n      backwards by calling this function with a negative input\n\n    Args:\n        distance (float): The distance to move forward\n\n    Returns:\n        Turtle: Return self so that commands can be chained\n    \"\"\"\n    dx, dy = distance * np.cos(self.heading_rad), distance * np.sin(\n        self.heading_rad\n    )\n    return self.goto(self.x + dx, self.y + dy)\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.goto","title":"<code>goto(x, y)</code>","text":"<p>Move the turtle directly to a given coordinate</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate of the point to which to go</p> required <code>y</code> <code>float</code> <p>The y-coordinate of the point to which to go</p> required <p>Returns:</p> Name Type Description <code>Turtle</code> <code>Turtle</code> <p>Return self so that commands can be chained</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def goto(self, x: float, y: float) -&gt; Turtle:\n    \"\"\"Move the turtle directly to a given coordinate\n\n    Args:\n        x (float): The x-coordinate of the point to which to go\n        y (float): The y-coordinate of the point to which to go\n\n    Returns:\n        Turtle: Return self so that commands can be chained\n    \"\"\"\n    new_pos = shapely.Point(x, y)\n    if self.pen_down:\n        self._current_line.append(new_pos)\n    self._state = dataclasses.replace(self._state, position=new_pos)\n    return self\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.lower_pen","title":"<code>lower_pen()</code>","text":"<p>Lower the pen so that lines are created when the turtle moves</p> <p>Returns:</p> Name Type Description <code>Turtle</code> <code>Turtle</code> <p>Return self so that commands can be chained</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def lower_pen(self) -&gt; Turtle:\n    \"\"\"Lower the pen so that lines are created when the turtle moves\n\n    Returns:\n        Turtle: Return self so that commands can be chained\n    \"\"\"\n    self._current_line = [self.position]\n    self._state = dataclasses.replace(self._state, pen_down=True)\n    return self\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.pop","title":"<code>pop()</code>","text":"<p>Pop the top state from the stack and revert the turtle to that state. New lines are not created by the turtle jumping back to this old state.</p> <p>Returns:</p> Name Type Description <code>Turtle</code> <code>Turtle</code> <p>Return self so that commands can be chained</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def pop(self) -&gt; Turtle:\n    \"\"\"Pop the top state from the stack and revert the turtle to that state.\n    New lines are not created by the turtle jumping back to this old state.\n\n    Returns:\n        Turtle: Return self so that commands can be chained\n    \"\"\"\n    self.raise_pen()\n    self._state = self._stack.pop()\n    if self.pen_down:\n        self._current_line = [self.position]\n    return self\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.push","title":"<code>push()</code>","text":"<p>Push the turtle's current state (position &amp; angle) onto a stack so that the turtle can revert to that position later</p> <p>Returns:</p> Name Type Description <code>Turtle</code> <code>Turtle</code> <p>Return self so that commands can be chained</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def push(self) -&gt; Turtle:\n    \"\"\"Push the turtle's current state (position &amp; angle) onto a stack\n    so that the turtle can revert to that position later\n\n    Returns:\n        Turtle: Return self so that commands can be chained\n    \"\"\"\n    self._stack.append(self._state)\n    return self\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.raise_pen","title":"<code>raise_pen()</code>","text":"<p>Lift the pen so that lines are not created when the turtle moves</p> <p>Returns:</p> Name Type Description <code>Turtle</code> <code>Turtle</code> <p>Return self so that commands can be chained</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def raise_pen(self) -&gt; Turtle:\n    \"\"\"Lift the pen so that lines are not created when the turtle moves\n\n    Returns:\n        Turtle: Return self so that commands can be chained\n    \"\"\"\n    if len(self._current_line) &gt; 1:\n        self._lines.append(shapely.LineString(self._current_line))\n    self._current_line = [self.position]\n    self._state = dataclasses.replace(self._state, pen_down=False)\n    return self\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.turn","title":"<code>turn(angle)</code>","text":"<p>Rotate clockwise by some angle. To rotate counterclockwise, pass a negative angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>The angle by which to rotate</p> required <p>Returns:</p> Name Type Description <code>Turtle</code> <code>Turtle</code> <p>Return self so that commands can be chained</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def turn(self, angle: float) -&gt; Turtle:\n    \"\"\"Rotate clockwise by some angle. To rotate counterclockwise, pass a negative angle.\n\n    Args:\n        angle (float): The angle by which to rotate\n\n    Returns:\n        Turtle: Return self so that commands can be chained\n    \"\"\"\n    return self.turn_right(angle)\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.turn_left","title":"<code>turn_left(angle)</code>","text":"<p>Rotate anti-clockwise by some angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>The angle by which to rotate</p> required <p>Returns:</p> Name Type Description <code>Turtle</code> <code>Turtle</code> <p>Return self so that commands can be chained</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def turn_left(self, angle: float) -&gt; Turtle:\n    \"\"\"Rotate anti-clockwise by some angle.\n\n    Args:\n        angle (float): The angle by which to rotate\n\n    Returns:\n        Turtle: Return self so that commands can be chained\n    \"\"\"\n    return self.turn_right(-angle)\n</code></pre>"},{"location":"api_ref/turtle/#elkplot.turtle.Turtle.turn_right","title":"<code>turn_right(angle)</code>","text":"<p>Rotate clockwise by some angle. (This is an alias for turn)</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>The angle by which to rotate</p> required <p>Returns:</p> Name Type Description <code>Turtle</code> <code>Turtle</code> <p>Return self so that commands can be chained</p> Source code in <code>elkplot/turtle.py</code> <pre><code>def turn_right(self, angle: float) -&gt; Turtle:\n    \"\"\"Rotate clockwise by some angle. (This is an alias for turn)\n\n    Args:\n        angle (float): The angle by which to rotate\n\n    Returns:\n        Turtle: Return self so that commands can be chained\n    \"\"\"\n    new_heading = self.heading_rad + angle * (\n        DEG_TO_RAD if self._use_degrees else 1\n    )\n    self._state = dataclasses.replace(self._state, heading=new_heading)\n    return self\n</code></pre>"}]}